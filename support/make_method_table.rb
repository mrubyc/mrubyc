#!/usr/bin/env ruby
# coding: utf-8
#
# create built-in method table include file.
#
#  Copyright (C) 2015- Kyushu Institute of Technology.
#  Copyright (C) 2015- Shimane IT Open-Innovation Center.
#
#  This file is distributed under BSD 3-Clause License.
#
# (usage)
# ruby make_method_table.rb TARGET_CLASS_FILE.c
#

require_relative "common_sub"


##
# write header file
#
def write_file( param )
  flag_error = false

  begin
    if param[:file]
      file = File.open( param[:file], "w" )
    elsif param[:append]
      file = File.open( param[:append], "a" )
    else
      file = $stdout
    end

  rescue Errno::ENOENT
    puts "File can't open. #{param[:file]}"
    return false
  end

  if param[:file] || file == $stdout
    file.puts <<EOL
/* Auto generated by make_method_table.rb */
#include "_autogen_builtin_symbol.h"
EOL
  else
    file.puts
  end

  param[:classes].each {|cls|
    if cls[:class]
      type = :class
    elsif cls[:module]
      type = :module
    else
      raise
    end
    cls_name = cls[type]

    file.puts "\n/*===== #{cls_name} #{type} =====*/"
    if !cls[:methods].empty?
      cls[:methods].sort_by! {|m| m[:name] }    # sort by method name

      # write method symbol table.
      file.puts "static const mrbc_sym method_symbols_#{cls_name}[] = {"
      cls[:methods].each {|m|
        file.puts m[:if_exp].join("\n")  if m[:if_exp]
        file.puts "  MRBC_SYM(#{rename_for_symbol(m[:name])}),"
        m[:if_exp].size.times { file.puts "#endif" }  if m[:if_exp]
      }
      file.puts "};\n\n"

      # write method function table.
      file.puts "static const mrbc_func_t method_functions_#{cls_name}[] = {"
      cls[:methods].each {|m|
        file.puts m[:if_exp].join("\n")  if m[:if_exp]
        file.puts "  #{m[:func]},"
        m[:if_exp].size.times { file.puts "#endif" }  if m[:if_exp]
      }
      file.puts "};\n\n"
    end

    # write class struct.
    struct_name = cls[:methods].empty? ? "RBuiltinNoMethodClass" : "RBuiltinClass"
    file.puts "struct #{struct_name} mrbc_class_#{cls_name} = {"
    file.puts "  .sym_id = MRBC_SYM(#{cls_name}),"
    file.puts "  .flag_builtin = 1,"
    file.puts "  .flag_nomethod = 1,"  if struct_name == "RBuiltinNoMethodClass"
    file.puts "  .flag_module = 1,"  if type == :module

    n = cls[:methods].empty? ? "0" : "sizeof(method_symbols_#{cls_name}) / sizeof(mrbc_sym)"
    file.puts "  .num_builtin_method = #{n},"
    sp = case cls[:super]
         when nil
           raise "SUPER isn't specified."
         when /^[A-Z][A-Za-z0-9]+$/
           "MRBC_CLASS(#{cls[:super]})"
         else
           cls[:super]
         end
    file.puts "  .super = #{sp},"
    file.puts "#if defined(MRBC_DEBUG)"
    file.puts "  .obj_mark_ = \"#{type.to_s.upcase[0,2]}\","
    file.puts "  .name = \"#{cls_name}\","
    file.puts "#endif"

    if !cls[:methods].empty?
      file.puts "  .method_symbols = method_symbols_#{cls_name},"
      file.puts "  .method_functions = method_functions_#{cls_name},"
    end
    file.puts "};"
  }

  file.close  if file != $stdout
end


##
# main
#
output_dir = nil
args = []
i = 0
while i < ARGV.size
  if ARGV[i] == '--output-dir'
    i += 1
    output_dir = ARGV[i]
  else
    args << ARGV[i]
  end
  i += 1
end

if args.empty?
  puts <<EOL
(usage)
ruby make_method_table.rb [--output-dir DIR] TARGET_CLASS_FILE.c
EOL
  exit 1
end
filename = args[0]

begin
  file = File.open( filename )
rescue Errno::ENOENT
  puts "File not found. '#{filename}'"
  exit 1
end

src = get_method_table_source( file )
if !src
  puts %!Magic comment "MRBC_AUTOGEN_METHOD_TABLE" is not found. '#{filename}'!
  exit 1
end

while src
  param = parse_source_string( src )
  exit 1 if !param
  if output_dir
    param[:file]   = File.join(output_dir, param[:file])   if param[:file]
    param[:append] = File.join(output_dir, param[:append]) if param[:append]
  end
  write_file( param )

  src = get_method_table_source( file )
end
